---
title: Redis项目-黑马点评
published: 2024-12-13
description: 基于开源项目黑马点评，介绍Redis的实际使用场景
image: ./assets/918324ed212a175027405e850209fa82ab005d32.png
tags: [Redis]
category: 项目介绍
draft: false
---

# 1. 验证码登录

整体业务流程如下所示：![image-20241213222044969](./assets/image-20241213222044969.png)

## 1.1 发送短信验证码

核心代码：

```java
public Result sendCode(String phone, HttpSession session) {
    // 1. 校验手机号码是否合法
    if (RegexUtils.isPhoneInvalid(phone)) {
        return Result.fail("手机号码格式不正确");
    }
    // 2. 生成验证码
    String code = RandomUtil.randomNumbers(6);

    // 3. 保存验证码到session中
    session.setAttribute("code", code);

    // 4. 发送验证码到手机
    log.info("向手机号码：{} 发送验证码：{}", phone, code);

    return Result.ok();
}
```



## 1.2 验证码注册登录

核心代码：

```java
public Result login(LoginFormDTO loginForm, HttpSession session) {
    // 1. 校验手机号码是否合法
    if (RegexUtils.isPhoneInvalid(loginForm.getPhone())) {
        return Result.fail("手机号码格式不正确");
    }

    // 2. 校验验证码
    String code = (String) session.getAttribute("code");
    if (!loginForm.getCode().equals(code)) {
        return Result.fail("验证码错误");
    }

    // 3. 查询用户信息
    User user = query().eq("phone", loginForm.getPhone()).one();

    // 4. 判断用户是否存在
    if (user == null) {
        // 4.1 用户不存在，注册用户
        user = new User()
                .setPhone(loginForm.getPhone())
                .setNickName("user_" + UUID.randomUUID().toString().substring(0, 8));
        
        // 4.2 存入数据库
        save(user);
    }

    // 5. 保存用户信息到session中
    session.setAttribute("user", user);

    return Result.ok();
}
```



## 1.3 校验登录状态

![image-20241213224733382](./assets/image-20241213224733382.png)

拦截器核心代码：将用户信息存储在`ThreadLocal`以便后续服务获取用户信息

```java
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 从session中获取用户信息
        HttpSession session = request.getSession();
        UserDTO user = (UserDTO) session.getAttribute("user");
        // 2. 判断用户信息是否存在
        if (user == null) {
            response.setStatus(401);
            return false;
        }

        // 3. 保存用户信息到ThreadLocal中（只保留用户的基本信息）
        UserHolder.saveUser(BeanUtil.copyProperties(user, UserDTO.class));

        // 4. 放行
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除ThreadLocal中的用户信息
        UserHolder.removeUser();
    }
}
```

注册拦截器：将不需要用户信息的请求排除在外

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(
                        "/user/code", 
                        "/user/login",
                        "/blog/hot",
                        "/upload/**",
                        "/shop/**",
                        "/vocher/**",
                        "/shop-type/**");
    }
}
```



## 1.4 集群的Session共享问题

**session共享问题：** 多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。

![image-20241213230250165](./assets/image-20241213230250165.png)



## 1.5 使用Redis对登录进行改造

![image-20241213231722283](./assets/image-20241213231722283.png)

![image-20241213231910251](./assets/image-20241213231910251.png)



### 1. Redis存储验证码

```java
// 3. 保存验证码到session中
//session.setAttribute("code", code);
// 3.1 保存验证码到redis中
redisTemplate.opsForValue().set(RedisConstants.LOGIN_CODE_KEY + phone, code, RedisConstants.LOGIN_CODE_TTL, TimeUnit.MINUTES);
```



### 2. Redis校验验证码并存储用户信息

这边可以做简单的优化，登录成功之后销毁验证码

```java
// 2. 校验验证码
//String code = (String) session.getAttribute("code");
// 2.1 从redis中获取验证码
String code = redisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + loginForm.getPhone());

...
    
// 5. 保存用户信息到session中
//session.setAttribute("user", user);
// 5.1 保存用户信息到redis中
// 生成token
String token = UUID.randomUUID().toString();

// 将信息转为HashMap（由于使用的是StringRedisTemplate，因此要将所有类型转换成String）
Map<String, Object> map = BeanUtil.beanToMap(BeanUtil.copyProperties(user, UserDTO.class), new HashMap<>(),
                                             CopyOptions.create().setIgnoreNullValue(true).setFieldValueEditor(
                                                 (fieldName, value) -> value.toString()
                                             ));

// 保存到redis中
redisTemplate.opsForHash().putAll(RedisConstants.LOGIN_USER_KEY + token, map);
redisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);

...
    
// 将token返回给前端存储，以便之后读取用户信息
return Result.ok(token);
```



### 3. 校验登录状态

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 1. 从请求头中获取Token
    String token = request.getHeader("authorization");
    if (StrUtil.isBlank(token)) {
        response.setStatus(401);
        return false;
    }

    // 2. 从Redis中获取用户信息
    Map<Object, Object> userMap = redisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);

    // 3. 判断用户信息是否存在
    if (userMap.isEmpty()) {
        response.setStatus(401);
        return false;
    }

    // 4. 保存用户信息到ThreadLocal中
    UserHolder.saveUser(BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false));

    // 5. 刷新Token的过期时间
    redisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);

    // 6. 放行
    return true;
}
```



### 4. 拦截器优化

在上面介绍的这种方法中，只有当访问需要登录状态的路径时，才会对token进行刷新。因此需要增加一个拦截器，专门用于对token进行刷新，以确保用户的良好体验。

![image-20241213233724691](./assets/image-20241213233724691.png)

新增拦截器的代码：基本和之前的拦截器相同，只不过把部分返回`false`的地方改为放行给下一个拦截器验证

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 1. 从请求头中获取Token
    String token = request.getHeader("authorization");
    if (StrUtil.isBlank(token)) {
        // 未携带Token，放行给下一个拦截器
        return true;
    }

    // 2. 从Redis中获取用户信息
    Map<Object, Object> userMap = redisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);

    // 3. 判断用户信息是否存在
    if (userMap.isEmpty()) {
        // 放行给下一个拦截器
        return true;
    }

    // 4. 保存用户信息到ThreadLocal中
    UserHolder.saveUser(BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false));

    // 5. 刷新Token的过期时间
    redisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, RedisConstants.LOGIN_USER_TTL, TimeUnit.SECONDS);

    // 6. 放行
    return true;
}
```



原先拦截器修改后的代码：只需要判断用户信息是否存在即可

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 判断用户信息是否存在
    if (UserHolder.getUser() == null) {
        // 如果用户信息不存在，返回401状态码
        response.setStatus(401);
        return false;
    }
    
    return true;
}
```



最后修改配置文件，将新拦截器放置于旧拦截器之前

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Autowired
    private StringRedisTemplate redisTemplate;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new RefreshTokenInterceptor(redisTemplate)).order(0);
        
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(
                        "/user/code",
                        "/user/login",
                        "/blog/hot",
                        "/upload/**",
                        "/shop/**",
                        "/vocher/**",
                        "/shop-type/**").order(1);
        
    }
}
```



# 2. 商户查询缓存

## 2.1 添加商户缓存

![image-20241214165731174](./assets/image-20241214165731174.png)

核心代码：

```java
public Result queryById(Long id) {
    String key = RedisConstants.CACHE_SHOP_KEY + id;
    // 1. 从缓存中查询
    String shopJson = redisTemplate.opsForValue().get(key);

    // 2. 如果缓存中有，直接返回
    if (StrUtil.isBlank(shopJson)) {
        // 3. 如果缓存中没有，从数据库中查询
        Shop shop = getById(id);
        if (shop == null) {
            return Result.fail("商铺不存在");
        }
        shopJson = JSONUtil.toJsonStr(shop);

        // 4. 如果数据库中有，将数据写入缓存
        redisTemplate.opsForValue().set(key, shopJson);
    }

    return Result.ok(JSONUtil.toBean(shopJson, Shop.class));
}
```



同时，我们还可以给商户的分类信息进行缓存，这里提供两种方式：

方法1：以`String`形式存储

```java
public List<ShopType> queryTypeList() {
    // 1. 从缓存中查询
    String list = redisTemplate.opsForValue().get(RedisConstants.SHOP_TYPE_LIST);

    // 2. 如果缓存中有，直接返回
    if (StrUtil.isBlank(list)) {
        // 3. 如果缓存中没有，从数据库中查询
        List<ShopType> shopTypes = query().orderByAsc("sort").list();
        list = JSONUtil.toJsonStr(shopTypes);
        // 4. 将数据写入缓存
        redisTemplate.opsForValue().set(RedisConstants.SHOP_TYPE_LIST, list);
    }

    return JSONUtil.toList(JSONUtil.parseArray(list), ShopType.class);
}
```

方法2：以`List`形式存储

```java
public List<ShopType> queryTypeList() {
    // 1. 从 Redis 缓存中查询数据（JSON 格式的 List）
    List<String> cachedList = redisTemplate.opsForList().range(RedisConstants.SHOP_TYPE_LIST, 0, -1);

    // 2. 如果缓存中有数据
    if (CollUtil.isNotEmpty(cachedList)) {
        // 将 JSON 字符串转换为 ShopType 对象
        return cachedList.stream()
                .map(json -> JSONUtil.toBean(json, ShopType.class))
                .collect(Collectors.toList());
    }

    // 3. 如果缓存中没有，从数据库中查询
    List<ShopType> shopTypes = query().orderByAsc("sort").list();

    // 4. 如果数据库中有数据，将其序列化为 JSON 并存入 Redis
    if (CollUtil.isNotEmpty(shopTypes)) {
        List<String> jsonList = shopTypes.stream()
                .map(JSONUtil::toJsonStr)
                .collect(Collectors.toList());
        redisTemplate.opsForList().rightPushAll(RedisConstants.SHOP_TYPE_LIST, jsonList);
    }

    return shopTypes;
}
```



## 2.2 缓存更新策略

![image-20241214174055363](./assets/image-20241214174055363.png)

**常见的主动更新策略：**

![image-20241214174222213](./assets/image-20241214174222213.png)

在实际开放中，常常采用第一种策略来更新缓存

![image-20241214174458941](./assets/image-20241214174458941.png)

针对第三个问题，我们可以看以下两张图：

- 先删除缓存，再操作数据库：由于查询的性能通常较高，因此右边这种异常状况较容易发生

![image-20241214175025442](./assets/image-20241214175025442.png)

- 先操作数据库，再删除缓存：通常来说，线程1中的这些操作要比线程2中的快许多，因此这种异常发生的概率较小

![image-20241214175443401](./assets/image-20241214175443401.png)

## 2.3 设置查询店铺的缓存更新

1. 给缓存添加超时时间。

   ```java
   // 设置过期时间
   redisTemplate.opsForValue().set(key, shopJson, RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);
   ```

2. 更新店铺信息时，先修改数据库后删除缓存。同时使用`@Transactional`注解保证事务一致性。

   ```java
   @Transactional
   public Boolean updateShop(Shop shop) {
       // 1. 查询商铺信息
       Shop oldShop = getById(shop.getId());
   
       // 2. 检测商铺是否存在
       if (oldShop == null) {
           log.error("商铺不存在，id: " + shop.getId());
           return false;
       }
   
       // 3. 更新商铺信息
       updateById(shop);
   
       // 4. 删除缓存
       redisTemplate.delete(RedisConstants.CACHE_SHOP_KEY + shop.getId());
   
       return true;
   }
   ```

   

## 2.4 缓存穿透

缓存穿透是指用户请求的数据既不存在于缓存中，也不存在于数据库中，导致请求直接穿过缓存层，打到数据库。由于大量无效请求直接访问数据库，会对数据库造成很大的压力，甚至可能导致数据库崩溃。



### 1. 缓存穿透的典型场景

1. **恶意请求**：
   - 攻击者构造大量不存在的键（如随机生成的用户 ID），直接绕过缓存层，给数据库造成压力。
2. **请求的键本身不合法**：
   - 比如查询一个负数 ID 或超大 ID，这些数据通常既不在缓存中，也不会存储在数据库中。
3. **缓存未命中且数据库无该数据**：
   - 用户请求的数据确实不存在，缓存也没存储对应的空值，导致每次都需要查询数据库。



### 2. 缓存穿透的影响

1. **缓存无效**：
   - 缓存失去了缓解数据库压力的作用。
2. **数据库压力骤增**：
   - 高频无效请求直接打到数据库，可能引发性能瓶颈或宕机。
3. **系统资源浪费**：
   - 数据库和网络资源都被浪费在无效请求上，影响正常用户的访问。



### 3. 解决缓存穿透的常用方法

1. **缓存空值：** 如果查询的结果为空（数据库中也没有），将空值写入缓存，并设置较短的过期时间。
2. **布隆过滤器：**
   - 在查询缓存或数据库之前，使用布隆过滤器快速判断一个键是否存在。
   - 布隆过滤器使用少量内存维护一个可能存在的键集合，能够高效地过滤掉大部分无效请求。
   - 特点：
     - 存在一定的误判率（可能误判不存在的键为存在）。
     - 不会漏判（不会将存在的键误判为不存在）。

![image-20241214191012250](./assets/image-20241214191012250.png)



### 4. 使用缓存空值优化店铺查询

![image-20241214192043718](./assets/image-20241214192043718.png)

核心修改代码如下所示：

```java
// 防止缓存穿透
if (StrUtil.equals("", shopJson)) {
    return Result.fail("商铺不存在");
}

// 3. 如果缓存中没有，从数据库中查询
Shop shop = getById(id);
if (shop == null) {
    // 缓存一个空值，防止缓存穿透
    redisTemplate.opsForValue().set(key, "", RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);
    return Result.fail("商铺不存在");
}
```



## 2.5 缓存雪崩

缓存雪崩是指在同一时间大量缓存失效，导致大量请求直接涌向后端数据库或服务，引发数据库或服务的性能瓶颈甚至崩溃的现象。它通常发生在高并发、大流量的场景中，是分布式系统中缓存设计的一个重要问题。

![image-20241214192649231](./assets/image-20241214192649231.png)

### 1. 缓存雪崩的产生原因

1. **缓存集中失效**：
   - 系统中大量的缓存数据设置了相同或相近的过期时间，一旦到期，大量请求同时绕过缓存，直接访问后端。
2. **缓存服务崩溃**：
   - 缓存服务（如 Redis、Memcached）因故障（如宕机、网络问题）导致所有缓存数据不可用，大量请求直接涌向数据库。
3. **高并发场景的缓存穿透**：
   - 请求的目标数据本身不在缓存中（如查询无效的键），直接对数据库发起大量访问。



### 2. 缓存雪崩的影响

1. **数据库或服务压力骤增**：
   - 短时间内大量请求绕过缓存直达数据库，可能导致服务不可用。
2. **系统响应时间急剧增加**：
   - 数据库、服务超负荷运行，导致请求延迟增加或直接失败。
3. **系统雪崩效应**：
   - 一旦数据库因过载崩溃，整个系统可能陷入不可用状态，最终对用户体验产生严重影响。



### 3. 缓存雪崩的解决方案

**1. 缓存过期时间的设计**

- 设置随机过期时间：避免所有缓存集中失效，可以在过期时间的基础上增加一个随机值。

  ```java
  int baseExpire = 3600; // 基础过期时间 1 小时
  int randomExpire = ThreadLocalRandom.current().nextInt(300); // 随机增加 0~300 秒
  redisTemplate.expire("key", baseExpire + randomExpire, TimeUnit.SECONDS);
  ```

- 分散缓存失效时间： 对不同类型的数据设置不同的过期时间。



**2. 缓存预热**

- 主动加载缓存：在系统启动或大流量访问前，提前将热点数据加载到缓存中，避免缓存为空导致请求直接落到数据库。

  - 示例：

    ```java
    public void warmUpCache() {
        List<HotData> hotData = database.queryHotData();
        for (HotData data : hotData) {
            redisTemplate.opsForValue().set(data.getKey(), data.getValue(), 1, TimeUnit.HOURS);
        }
    }
    ```

- 定期更新缓存： 使用后台任务定时刷新部分热点数据，确保缓存中始终有有效数据。



**3. 缓存降级**

- 使用默认值： 在缓存和数据库都不可用时，返回默认值或空数据，保证系统的基本可用性。
  - 示例：返回一个默认的商品列表或提示信息。
- 快速失败： 对非核心业务请求，直接返回失败，防止系统进一步过载。



**4. 增加缓存冗余**

- 多级缓存：结合本地缓存（如 Guava Cache、Caffeine）和分布式缓存（如 Redis），实现多级缓存架构。

  - 本地缓存作为第一层，减少对 Redis 的访问。
  - 如果本地缓存未命中，再访问 Redis。

  示例：多级缓存架构

  - 请求流程：
    1. 先查询本地缓存。
    2. 本地缓存未命中时，查询 Redis 缓存。
    3. Redis 未命中时，查询数据库，并更新 Redis 和本地缓存。



**5. 限流与熔断**

- 请求限流： 使用限流策略对请求量进行控制，避免流量过大导致后端数据库崩溃。
  - 示例：使用令牌桶算法或漏桶算法限制每秒请求数。
- 熔断机制： 当后端服务响应时间过长或错误率过高时，直接返回错误或默认数据，保护系统。



**6. 缓存服务高可用**

- Redis 哨兵模式： 部署 Redis 的主从架构和哨兵模式，确保缓存服务的高可用。主节点宕机时，哨兵会自动切换到从节点。
- 分布式缓存集群： 使用 Redis Cluster，分布式存储数据，避免单点故障。



## 2.6 缓存击穿

缓存击穿是指在高并发场景中，某个热点数据的缓存失效，导致大量并发请求同时访问数据库的现象。它通常发生在某些访问量极大的热点数据上，如果设计不当，可能会对数据库或后端服务造成瞬时的高负载压力，甚至引发系统崩溃。

![image-20241214193218579](./assets/image-20241214193218579.png)

### 1. 缓存击穿的典型场景

1. **热点数据缓存失效** ：一个高频访问的热点键（例如秒杀商品详情）突然过期，缓存中没有数据，导致所有请求直接访问数据库。
2. **高并发访问** ：短时间内有大量请求访问同一数据，而缓存又未命中时，所有请求会同时落到数据库。



### 2. 缓存击穿的影响

- **数据库压力骤增**： 如果大量请求绕过缓存直接访问数据库，数据库很容易负载过高，影响其他业务。
- **系统响应时间增加**： 用户请求需要等待数据库查询完成，导致系统延迟增加。
- **引发系统雪崩**： 在极端情况下，数据库因过载崩溃，进而导致系统不可用。



### 3. 缓存击穿的解决方案

1. **使用互斥锁**：当缓存失效时，使用分布式锁（如 Redis 的 `setnx`）保证只有一个线程能查询数据库并更新缓存，其他线程等待缓存更新完成后再读取缓存。
2. **逻辑过期**：将过期时间存储在缓存中，而key设置为永不过期，等到合适的时间再统一清理或更新

![image-20241214194508634](./assets/image-20241214194508634.png)

![image-20241214194649443](./assets/image-20241214194649443.png)



## 2.7 缓存击穿解决实战

### 1. 互斥锁解决

![image-20241214200049816](./assets/image-20241214200049816.png)

**核心代码**

构建操作锁的方法：

```java
public boolean tryLock(String key){
    Boolean b = redisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
    return BooleanUtil.isTrue(b);
}

public void unlock(String key){
    redisTemplate.delete(key);
}
```

程序中使用互斥锁避免击穿

```java
private Shop queryWithMutex(Long id) {
    String key = RedisConstants.CACHE_SHOP_KEY + id;
    String lockKey = RedisConstants.LOCK_SHOP_KEY + id;
    // 1. 从缓存中查询
    String shopJson = redisTemplate.opsForValue().get(key);

    // 2. 如果缓存中有，直接返回
    if (StrUtil.isBlank(shopJson)) {

        try {
            boolean lock = tryLock(lockKey);

            // 如果获取锁失败，等待一段时间后重试
            if (!lock) {
                Thread.sleep(50);
                return queryWithMutex(id);
            }

            // 3. 如果缓存中没有，从数据库中查询
            Shop shop = getById(id);
            if (shop == null) {
                return null;
            }
            shopJson = JSONUtil.toJsonStr(shop);

            // 4. 如果数据库中有，将数据写入缓存
            redisTemplate.opsForValue().set(key, shopJson, RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            // 释放锁
            unlock(lockKey);
        }
    }
    return JSONUtil.toBean(shopJson, Shop.class);
}
```

### 2. 逻辑过期解决

![image-20241214210215180](./assets/image-20241214210215180.png)





## 2. 缓存问题总结分析

| 特性         | 缓存击穿                         | 缓存穿透                     | 缓存雪崩                     |
| ------------ | -------------------------------- | ---------------------------- | ---------------------------- |
| **描述**     | 热点数据失效，大量请求涌向数据库 | 请求无效键，缓存和数据库均无 | 大量缓存同时失效，访问数据库 |
| **触发条件** | 单一热点键过期或失效             | 无效请求或恶意请求           | 缓存集中失效或缓存服务不可用 |
| **影响范围** | 单一热点数据                     | 对单一请求影响较大           | 大面积影响整个系统           |
| **解决方式** | 互斥锁、预热、永不过期           | 布隆过滤器、参数校验         | 随机过期、预热、多级缓存     |