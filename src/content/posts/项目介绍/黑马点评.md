---
title: Redis项目-黑马点评
published: 2024-12-13
description: 基于开源项目黑马点评，介绍Redis的实际使用场景
image: ./assets/918324ed212a175027405e850209fa82ab005d32.png
tags: [Redis]
category: 项目介绍
draft: false
---

# 1. 验证码登录

整体业务流程如下所示：![image-20241213222044969](./assets/image-20241213222044969.png)

## 1.1 发送短信验证码

核心代码：

```java
public Result sendCode(String phone, HttpSession session) {
    // 1. 校验手机号码是否合法
    if (RegexUtils.isPhoneInvalid(phone)) {
        return Result.fail("手机号码格式不正确");
    }
    // 2. 生成验证码
    String code = RandomUtil.randomNumbers(6);

    // 3. 保存验证码到session中
    session.setAttribute("code", code);

    // 4. 发送验证码到手机
    log.info("向手机号码：{} 发送验证码：{}", phone, code);

    return Result.ok();
}
```



## 1.2 验证码注册登录

核心代码：

```java
public Result login(LoginFormDTO loginForm, HttpSession session) {
    // 1. 校验手机号码是否合法
    if (RegexUtils.isPhoneInvalid(loginForm.getPhone())) {
        return Result.fail("手机号码格式不正确");
    }

    // 2. 校验验证码
    String code = (String) session.getAttribute("code");
    if (!loginForm.getCode().equals(code)) {
        return Result.fail("验证码错误");
    }

    // 3. 查询用户信息
    User user = query().eq("phone", loginForm.getPhone()).one();

    // 4. 判断用户是否存在
    if (user == null) {
        // 4.1 用户不存在，注册用户
        user = new User()
                .setPhone(loginForm.getPhone())
                .setNickName("user_" + UUID.randomUUID().toString().substring(0, 8));
        
        // 4.2 存入数据库
        save(user);
    }

    // 5. 保存用户信息到session中
    session.setAttribute("user", user);

    return Result.ok();
}
```



## 1.3 校验登录状态

![image-20241213224733382](./assets/image-20241213224733382.png)

拦截器核心代码：将用户信息存储在`ThreadLocal`以便后续服务获取用户信息

```java
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 从session中获取用户信息
        HttpSession session = request.getSession();
        UserDTO user = (UserDTO) session.getAttribute("user");
        // 2. 判断用户信息是否存在
        if (user == null) {
            response.setStatus(401);
            return false;
        }

        // 3. 保存用户信息到ThreadLocal中（只保留用户的基本信息）
        UserHolder.saveUser(BeanUtil.copyProperties(user, UserDTO.class));

        // 4. 放行
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除ThreadLocal中的用户信息
        UserHolder.removeUser();
    }
}
```

注册拦截器：将不需要用户信息的请求排除在外

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(
                        "/user/code", 
                        "/user/login",
                        "/blog/hot",
                        "/upload/**",
                        "/shop/**",
                        "/vocher/**",
                        "/shop-type/**");
    }
}
```



## 1.4 集群的Session共享问题

**session共享问题：** 多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。

![image-20241213230250165](./assets/image-20241213230250165.png)



## 1.5 使用Redis对登录进行改造

![image-20241213231722283](./assets/image-20241213231722283.png)

![image-20241213231910251](./assets/image-20241213231910251.png)



### 1. Redis存储验证码

```java
// 3. 保存验证码到session中
//session.setAttribute("code", code);
// 3.1 保存验证码到redis中
redisTemplate.opsForValue().set(RedisConstants.LOGIN_CODE_KEY + phone, code, RedisConstants.LOGIN_CODE_TTL, TimeUnit.MINUTES);
```



### 2. Redis校验验证码并存储用户信息

这边可以做简单的优化，登录成功之后销毁验证码

```java
// 2. 校验验证码
//String code = (String) session.getAttribute("code");
// 2.1 从redis中获取验证码
String code = redisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + loginForm.getPhone());

...
    
// 5. 保存用户信息到session中
//session.setAttribute("user", user);
// 5.1 保存用户信息到redis中
// 生成token
String token = UUID.randomUUID().toString();

// 将信息转为HashMap（由于使用的是StringRedisTemplate，因此要将所有类型转换成String）
Map<String, Object> map = BeanUtil.beanToMap(BeanUtil.copyProperties(user, UserDTO.class), new HashMap<>(),
                                             CopyOptions.create().setIgnoreNullValue(true).setFieldValueEditor(
                                                 (fieldName, value) -> value.toString()
                                             ));

// 保存到redis中
redisTemplate.opsForHash().putAll(RedisConstants.LOGIN_USER_KEY + token, map);
redisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);

...
    
// 将token返回给前端存储，以便之后读取用户信息
return Result.ok(token);
```



### 3. 校验登录状态

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 1. 从请求头中获取Token
    String token = request.getHeader("authorization");
    if (StrUtil.isBlank(token)) {
        response.setStatus(401);
        return false;
    }

    // 2. 从Redis中获取用户信息
    Map<Object, Object> userMap = redisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);

    // 3. 判断用户信息是否存在
    if (userMap.isEmpty()) {
        response.setStatus(401);
        return false;
    }

    // 4. 保存用户信息到ThreadLocal中
    UserHolder.saveUser(BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false));

    // 5. 刷新Token的过期时间
    redisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);

    // 6. 放行
    return true;
}
```



### 4. 拦截器优化

在上面介绍的这种方法中，只有当访问需要登录状态的路径时，才会对token进行刷新。因此需要增加一个拦截器，专门用于对token进行刷新，以确保用户的良好体验。

![image-20241213233724691](./assets/image-20241213233724691.png)

新增拦截器的代码：基本和之前的拦截器相同，只不过把部分返回`false`的地方改为放行给下一个拦截器验证

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 1. 从请求头中获取Token
    String token = request.getHeader("authorization");
    if (StrUtil.isBlank(token)) {
        // 未携带Token，放行给下一个拦截器
        return true;
    }

    // 2. 从Redis中获取用户信息
    Map<Object, Object> userMap = redisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);

    // 3. 判断用户信息是否存在
    if (userMap.isEmpty()) {
        // 放行给下一个拦截器
        return true;
    }

    // 4. 保存用户信息到ThreadLocal中
    UserHolder.saveUser(BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false));

    // 5. 刷新Token的过期时间
    redisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, RedisConstants.LOGIN_USER_TTL, TimeUnit.SECONDS);

    // 6. 放行
    return true;
}
```



原先拦截器修改后的代码：只需要判断用户信息是否存在即可

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 判断用户信息是否存在
    if (UserHolder.getUser() == null) {
        // 如果用户信息不存在，返回401状态码
        response.setStatus(401);
        return false;
    }
    
    return true;
}
```



最后修改配置文件，将新拦截器放置于旧拦截器之前

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Autowired
    private StringRedisTemplate redisTemplate;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new RefreshTokenInterceptor(redisTemplate)).order(0);
        
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(
                        "/user/code",
                        "/user/login",
                        "/blog/hot",
                        "/upload/**",
                        "/shop/**",
                        "/vocher/**",
                        "/shop-type/**").order(1);
        
    }
}
```



# 2. 商户查询缓存

## 2.1 添加商户缓存

![image-20241214165731174](./assets/image-20241214165731174.png)

核心代码：

```java
public Result queryById(Long id) {
    String key = RedisConstants.CACHE_SHOP_KEY + id;
    // 1. 从缓存中查询
    String shopJson = redisTemplate.opsForValue().get(key);

    // 2. 如果缓存中有，直接返回
    if (StrUtil.isBlank(shopJson)) {
        // 3. 如果缓存中没有，从数据库中查询
        Shop shop = getById(id);
        if (shop == null) {
            return Result.fail("商铺不存在");
        }
        shopJson = JSONUtil.toJsonStr(shop);

        // 4. 如果数据库中有，将数据写入缓存
        redisTemplate.opsForValue().set(key, shopJson);
    }

    return Result.ok(JSONUtil.toBean(shopJson, Shop.class));
}
```



同时，我们还可以给商户的分类信息进行缓存，这里提供两种方式：

方法1：以`String`形式存储

```java
public List<ShopType> queryTypeList() {
    // 1. 从缓存中查询
    String list = redisTemplate.opsForValue().get(RedisConstants.SHOP_TYPE_LIST);

    // 2. 如果缓存中有，直接返回
    if (StrUtil.isBlank(list)) {
        // 3. 如果缓存中没有，从数据库中查询
        List<ShopType> shopTypes = query().orderByAsc("sort").list();
        list = JSONUtil.toJsonStr(shopTypes);
        // 4. 将数据写入缓存
        redisTemplate.opsForValue().set(RedisConstants.SHOP_TYPE_LIST, list);
    }

    return JSONUtil.toList(JSONUtil.parseArray(list), ShopType.class);
}
```

方法2：以`List`形式存储

```java
public List<ShopType> queryTypeList() {
    // 1. 从 Redis 缓存中查询数据（JSON 格式的 List）
    List<String> cachedList = redisTemplate.opsForList().range(RedisConstants.SHOP_TYPE_LIST, 0, -1);

    // 2. 如果缓存中有数据
    if (CollUtil.isNotEmpty(cachedList)) {
        // 将 JSON 字符串转换为 ShopType 对象
        return cachedList.stream()
                .map(json -> JSONUtil.toBean(json, ShopType.class))
                .collect(Collectors.toList());
    }

    // 3. 如果缓存中没有，从数据库中查询
    List<ShopType> shopTypes = query().orderByAsc("sort").list();

    // 4. 如果数据库中有数据，将其序列化为 JSON 并存入 Redis
    if (CollUtil.isNotEmpty(shopTypes)) {
        List<String> jsonList = shopTypes.stream()
                .map(JSONUtil::toJsonStr)
                .collect(Collectors.toList());
        redisTemplate.opsForList().rightPushAll(RedisConstants.SHOP_TYPE_LIST, jsonList);
    }

    return shopTypes;
}
```



## 2.2 缓存更新策略

![image-20241214174055363](./assets/image-20241214174055363.png)

**常见的主动更新策略：**

![image-20241214174222213](./assets/image-20241214174222213.png)

在实际开放中，常常采用第一种策略来更新缓存

![image-20241214174458941](./assets/image-20241214174458941.png)

针对第三个问题，我们可以看以下两张图：

- 先删除缓存，再操作数据库：由于查询的性能通常较高，因此右边这种异常状况较容易发生

![image-20241214175025442](./assets/image-20241214175025442.png)

- 先操作数据库，再删除缓存：通常来说，线程1中的这些操作要比线程2中的快许多，因此这种异常发生的概率较小

![image-20241214175443401](./assets/image-20241214175443401.png)

## 2.3 设置查询店铺的缓存更新

1. 给缓存添加超时时间。

   ```java
   // 设置过期时间
   redisTemplate.opsForValue().set(key, shopJson, RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);
   ```

2. 更新店铺信息时，先修改数据库后删除缓存。同时使用`@Transactional`注解保证事务一致性。

   ```java
   @Transactional
   public Boolean updateShop(Shop shop) {
       // 1. 查询商铺信息
       Shop oldShop = getById(shop.getId());
   
       // 2. 检测商铺是否存在
       if (oldShop == null) {
           log.error("商铺不存在，id: " + shop.getId());
           return false;
       }
   
       // 3. 更新商铺信息
       updateById(shop);
   
       // 4. 删除缓存
       redisTemplate.delete(RedisConstants.CACHE_SHOP_KEY + shop.getId());
   
       return true;
   }
   ```

   

## 2.4 缓存穿透

缓存穿透是指用户请求的数据既不存在于缓存中，也不存在于数据库中，导致请求直接穿过缓存层，打到数据库。由于大量无效请求直接访问数据库，会对数据库造成很大的压力，甚至可能导致数据库崩溃。



### 1. 缓存穿透的典型场景

1. **恶意请求**：
   - 攻击者构造大量不存在的键（如随机生成的用户 ID），直接绕过缓存层，给数据库造成压力。
2. **请求的键本身不合法**：
   - 比如查询一个负数 ID 或超大 ID，这些数据通常既不在缓存中，也不会存储在数据库中。
3. **缓存未命中且数据库无该数据**：
   - 用户请求的数据确实不存在，缓存也没存储对应的空值，导致每次都需要查询数据库。



### 2. 缓存穿透的影响

1. **缓存无效**：
   - 缓存失去了缓解数据库压力的作用。
2. **数据库压力骤增**：
   - 高频无效请求直接打到数据库，可能引发性能瓶颈或宕机。
3. **系统资源浪费**：
   - 数据库和网络资源都被浪费在无效请求上，影响正常用户的访问。



### 3. 解决缓存穿透的常用方法

1. **缓存空值：** 如果查询的结果为空（数据库中也没有），将空值写入缓存，并设置较短的过期时间。
2. **布隆过滤器：**
   - 在查询缓存或数据库之前，使用布隆过滤器快速判断一个键是否存在。
   - 布隆过滤器使用少量内存维护一个可能存在的键集合，能够高效地过滤掉大部分无效请求。
   - 特点：
     - 存在一定的误判率（可能误判不存在的键为存在）。
     - 不会漏判（不会将存在的键误判为不存在）。

![image-20241214191012250](./assets/image-20241214191012250.png)



### 4. 使用缓存空值优化店铺查询

![image-20241214192043718](./assets/image-20241214192043718.png)

核心修改代码如下所示：

```java
// 防止缓存穿透
if (StrUtil.equals("", shopJson)) {
    return Result.fail("商铺不存在");
}

// 3. 如果缓存中没有，从数据库中查询
Shop shop = getById(id);
if (shop == null) {
    // 缓存一个空值，防止缓存穿透
    redisTemplate.opsForValue().set(key, "", RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);
    return Result.fail("商铺不存在");
}
```



## 2.5 缓存雪崩

缓存雪崩是指在同一时间大量缓存失效，导致大量请求直接涌向后端数据库或服务，引发数据库或服务的性能瓶颈甚至崩溃的现象。它通常发生在高并发、大流量的场景中，是分布式系统中缓存设计的一个重要问题。

![image-20241214192649231](./assets/image-20241214192649231.png)

### 1. 缓存雪崩的产生原因

1. **缓存集中失效**：
   - 系统中大量的缓存数据设置了相同或相近的过期时间，一旦到期，大量请求同时绕过缓存，直接访问后端。
2. **缓存服务崩溃**：
   - 缓存服务（如 Redis、Memcached）因故障（如宕机、网络问题）导致所有缓存数据不可用，大量请求直接涌向数据库。
3. **高并发场景的缓存穿透**：
   - 请求的目标数据本身不在缓存中（如查询无效的键），直接对数据库发起大量访问。



### 2. 缓存雪崩的影响

1. **数据库或服务压力骤增**：
   - 短时间内大量请求绕过缓存直达数据库，可能导致服务不可用。
2. **系统响应时间急剧增加**：
   - 数据库、服务超负荷运行，导致请求延迟增加或直接失败。
3. **系统雪崩效应**：
   - 一旦数据库因过载崩溃，整个系统可能陷入不可用状态，最终对用户体验产生严重影响。



### 3. 缓存雪崩的解决方案

**1. 缓存过期时间的设计**

- 设置随机过期时间：避免所有缓存集中失效，可以在过期时间的基础上增加一个随机值。

  ```java
  int baseExpire = 3600; // 基础过期时间 1 小时
  int randomExpire = ThreadLocalRandom.current().nextInt(300); // 随机增加 0~300 秒
  redisTemplate.expire("key", baseExpire + randomExpire, TimeUnit.SECONDS);
  ```

- 分散缓存失效时间： 对不同类型的数据设置不同的过期时间。



**2. 缓存预热**

- 主动加载缓存：在系统启动或大流量访问前，提前将热点数据加载到缓存中，避免缓存为空导致请求直接落到数据库。

  - 示例：

    ```java
    public void warmUpCache() {
        List<HotData> hotData = database.queryHotData();
        for (HotData data : hotData) {
            redisTemplate.opsForValue().set(data.getKey(), data.getValue(), 1, TimeUnit.HOURS);
        }
    }
    ```

- 定期更新缓存： 使用后台任务定时刷新部分热点数据，确保缓存中始终有有效数据。



**3. 缓存降级**

- 使用默认值： 在缓存和数据库都不可用时，返回默认值或空数据，保证系统的基本可用性。
  - 示例：返回一个默认的商品列表或提示信息。
- 快速失败： 对非核心业务请求，直接返回失败，防止系统进一步过载。



**4. 增加缓存冗余**

- 多级缓存：结合本地缓存（如 Guava Cache、Caffeine）和分布式缓存（如 Redis），实现多级缓存架构。

  - 本地缓存作为第一层，减少对 Redis 的访问。
  - 如果本地缓存未命中，再访问 Redis。

  示例：多级缓存架构

  - 请求流程：
    1. 先查询本地缓存。
    2. 本地缓存未命中时，查询 Redis 缓存。
    3. Redis 未命中时，查询数据库，并更新 Redis 和本地缓存。



**5. 限流与熔断**

- 请求限流： 使用限流策略对请求量进行控制，避免流量过大导致后端数据库崩溃。
  - 示例：使用令牌桶算法或漏桶算法限制每秒请求数。
- 熔断机制： 当后端服务响应时间过长或错误率过高时，直接返回错误或默认数据，保护系统。



**6. 缓存服务高可用**

- Redis 哨兵模式： 部署 Redis 的主从架构和哨兵模式，确保缓存服务的高可用。主节点宕机时，哨兵会自动切换到从节点。
- 分布式缓存集群： 使用 Redis Cluster，分布式存储数据，避免单点故障。



## 2.6 缓存击穿

缓存击穿是指在高并发场景中，某个热点数据的缓存失效，导致大量并发请求同时访问数据库的现象。它通常发生在某些访问量极大的热点数据上，如果设计不当，可能会对数据库或后端服务造成瞬时的高负载压力，甚至引发系统崩溃。

![image-20241214193218579](./assets/image-20241214193218579.png)

### 1. 缓存击穿的典型场景

1. **热点数据缓存失效** ：一个高频访问的热点键（例如秒杀商品详情）突然过期，缓存中没有数据，导致所有请求直接访问数据库。
2. **高并发访问** ：短时间内有大量请求访问同一数据，而缓存又未命中时，所有请求会同时落到数据库。



### 2. 缓存击穿的影响

- **数据库压力骤增**： 如果大量请求绕过缓存直接访问数据库，数据库很容易负载过高，影响其他业务。
- **系统响应时间增加**： 用户请求需要等待数据库查询完成，导致系统延迟增加。
- **引发系统雪崩**： 在极端情况下，数据库因过载崩溃，进而导致系统不可用。



### 3. 缓存击穿的解决方案

1. **使用互斥锁**：当缓存失效时，使用分布式锁（如 Redis 的 `setnx`）保证只有一个线程能查询数据库并更新缓存，其他线程等待缓存更新完成后再读取缓存。
2. **逻辑过期**：将过期时间存储在缓存中，而key设置为永不过期，等到合适的时间再统一清理或更新

![image-20241214194508634](./assets/image-20241214194508634.png)

![image-20241214194649443](./assets/image-20241214194649443.png)



## 2.7 缓存击穿解决实战

### 1. 互斥锁解决

![image-20241214200049816](./assets/image-20241214200049816.png)

**核心代码**

构建操作锁的方法：

```java
public boolean tryLock(String key){
    Boolean b = redisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
    return BooleanUtil.isTrue(b);
}

public void unlock(String key){
    redisTemplate.delete(key);
}
```

程序中使用互斥锁避免击穿

```java
private Shop queryWithMutex(Long id) {
    String key = RedisConstants.CACHE_SHOP_KEY + id;
    String lockKey = RedisConstants.LOCK_SHOP_KEY + id;
    // 1. 从缓存中查询
    String shopJson = redisTemplate.opsForValue().get(key);

    // 2. 如果缓存中有，直接返回
    if (StrUtil.isBlank(shopJson)) {

        try {
            boolean lock = tryLock(lockKey);

            // 如果获取锁失败，等待一段时间后重试
            if (!lock) {
                Thread.sleep(50);
                return queryWithMutex(id);
            }

            // 3. 如果缓存中没有，从数据库中查询
            Shop shop = getById(id);
            if (shop == null) {
                return null;
            }
            shopJson = JSONUtil.toJsonStr(shop);

            // 4. 如果数据库中有，将数据写入缓存
            redisTemplate.opsForValue().set(key, shopJson, RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            // 释放锁
            unlock(lockKey);
        }
    }
    return JSONUtil.toBean(shopJson, Shop.class);
}
```

### 2. 逻辑过期解决

![image-20241214210215180](./assets/image-20241214210215180.png)

首先，我们可以新建一个工具类，专门用于存储这类逻辑过期的数据

```java
public class RedisData {
    private LocalDateTime expireTime;
    private Object data;
}
```

然后专门编写一个辅助方法，用于更新店铺数据进Redis，方便后续使用

```java
private void saveShop2Redis(Long id, Long seconds) {
    String key = RedisConstants.CACHE_SHOP_KEY + id;
    Shop shop = getById(id);
    RedisData redisData = new RedisData().setData(shop).setExpireTime(LocalDateTime.now().plusSeconds(seconds));
    redisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));
}
```

核心代码：注意在使用这种方法时候要记得先将热点数据写入Redis进行预热

```java
private Shop queryWithLogicExpire(Long id) {
    // 1. 从缓存中查询
    String key = RedisConstants.CACHE_SHOP_KEY + id;
    String lockKey = RedisConstants.LOCK_SHOP_KEY + id;
    String shopJson = redisTemplate.opsForValue().get(key);

    // 2. 缓存未命中，返回空
    if (StrUtil.isBlank(shopJson)) {
        return null;
    }

    // 3. 缓存命中，判断是否过期
    RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
    if (redisData.getExpireTime().isBefore(LocalDateTime.now())) {
        // 3.1 缓存过期，异步刷新缓存
        tryLock(lockKey);
        executorService.execute(() -> saveShop2Redis(id, RedisConstants.CACHE_SHOP_TTL));
        unlock(lockKey);
    }

    // 4. 返回缓存数据
    JSONObject jsonObject = (JSONObject) redisData.getData();
    return jsonObject.toBean(Shop.class);
}
```



## 2.8 封装缓存工具类

![image-20241215105338139](./assets/image-20241215105338139.png)

工具类代码示例：

```java
@Component
public class RedisClient {
    private final StringRedisTemplate redisTemplate;

    private final ExecutorService executorService = Executors.newFixedThreadPool(10);

    public RedisClient(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    
    public void set(String key, Object value, Long time, TimeUnit timeUnit) {
        redisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit);
    }

    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit timeUnit) {
        RedisData redisData = new RedisData();
        redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time)));
        redisData.setData(value);
        redisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));
    }

    // 可解决缓存穿透问题
    public <R, ID> R get(String prefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit timeUnit) {
        String key = prefix + id;
        String value = redisTemplate.opsForValue().get(key);

        // 为空值缓存，直接返回null
        if (Objects.equals(value, "")) {
            return null;
        }
        
        // 缓存穿透解决方案
        if (value == null) {
            R result = dbFallback.apply(id);
            // 数据库中存在，写入缓存
            if (result != null) {
                set(key, result, time, timeUnit);
                return result;
            }
            // 数据库中不存在，写入空值缓存
            set(key, "", RedisConstants.CACHE_NULL_TTL, TimeUnit.SECONDS);
            return null;
        }
        return JSONUtil.toBean(value, type);

    }

    // 可解决缓存击穿问题
    public <R, ID> R getWithLogicalExpire(String prefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit timeUnit) {
        String key = prefix + id;
        String value = redisTemplate.opsForValue().get(key);

        // 不是热点数据，直接返回null
        if (StrUtil.isBlank(value)) {
            return null;
        }

        // 缓存逻辑过期解决方案
        RedisData redisData = JSONUtil.toBean(value, RedisData.class);
        if (LocalDateTime.now().isAfter(redisData.getExpireTime())) {
            if (tryLock(key)) {
                executorService.execute(() -> {
                    R result = dbFallback.apply(id);
                    if (result != null) {
                        setWithLogicalExpire(key, result, time, timeUnit);
                    }
                    unlock(key);
                });
            }
        }
        return JSONUtil.toBean(JSONUtil.toJsonStr(redisData.getData()), type);
    }
    
    public boolean tryLock(String key) {
        Boolean b = redisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
        return BooleanUtil.isTrue(b);
    }

    public void unlock(String key) {
        redisTemplate.delete(key);
    }
}
```



## 2.9 缓存问题总结分析

| 特性         | 缓存击穿                         | 缓存穿透                     | 缓存雪崩                     |
| ------------ | -------------------------------- | ---------------------------- | ---------------------------- |
| **描述**     | 热点数据失效，大量请求涌向数据库 | 请求无效键，缓存和数据库均无 | 大量缓存同时失效，访问数据库 |
| **触发条件** | 单一热点键过期或失效             | 无效请求或恶意请求           | 缓存集中失效或缓存服务不可用 |
| **影响范围** | 单一热点数据                     | 对单一请求影响较大           | 大面积影响整个系统           |
| **解决方式** | 互斥锁、预热、永不过期           | 布隆过滤器、参数校验         | 随机过期、预热、多级缓存     |



# 3. 优惠券秒杀

## 3.1 全局唯一ID

### 1. Redis实现

基于Redis的全局唯一ID生成策略：

![image-20241215120032985](./assets/image-20241215120032985.png)

实现代码：

```java
public class RedisIdWorker {
    private static final long BEGIN_TIME = 1704067200L;
    private static final int COUNT_BITS = 32;
    private StringRedisTemplate redisTemplate;

    public RedisIdWorker(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public long nextId(String keyPrefix) {
        long timestamp = LocalDateTime.now().toEpochSecond(ZoneOffset.UTC) - BEGIN_TIME;
        String key = "icr:" + keyPrefix + ":" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));

        long count = redisTemplate.opsForValue().increment(key, 1);

        return (timestamp << COUNT_BITS) | count;
    }
}
```



### 2. 雪花算法实现

雪花算法（Snowflake）是 Twitter 开发的一种分布式 ID 生成算法，生成的 ID 是一个 64 位的 long 型整数，具有全局唯一性和一定的有序性。

1. **ID 结构**：雪花算法的 ID 由以下部分组成（从高位到低位）：

   - **符号位**（1 位）：固定为 0，不使用。

   - **时间戳**（41 位）：相对于某个起始时间的毫秒数，可支持约 69 年。

   - **数据中心 ID**（5 位）：标识数据中心，可支持 32 个数据中心。

   - **机器 ID**（5 位）：标识单个节点，可支持 32 台机器。

   - **序列号**（12 位）：同一毫秒内的自增序号，可支持每毫秒生成 4096 个 ID。

​	**ID 格式**：0 | 41 位时间戳 | 5 位数据中心 ID | 5 位机器 ID | 12 位序列号

2. **优点**

   - **高性能**：每毫秒可生成数千个 ID。

   - **分布式支持**：适用于分布式系统，每个节点独立生成 ID。

   - **顺序性**：大致有序，适合数据库索引。

3. **缺点**

   - **时间依赖**：依赖系统时间，时间回拨可能导致 ID 冲突。

   - **实现复杂**：需要自行配置节点 ID 和时间戳逻辑。

实现代码：

```java
public class SnowflakeIdGenerator {
    private final long epoch = 1609459200000L; // 起始时间戳：2021-01-01
    private final long dataCenterIdBits = 5L; // 数据中心 ID 位数
    private final long workerIdBits = 5L;     // 机器 ID 位数
    private final long sequenceBits = 12L;   // 序列号位数

    private final long maxWorkerId = ~(-1L << workerIdBits);      // 最大机器 ID
    private final long maxDataCenterId = ~(-1L << dataCenterIdBits); // 最大数据中心 ID
    private final long sequenceMask = ~(-1L << sequenceBits);     // 最大序列号

    private final long workerIdShift = sequenceBits;                // 机器 ID 左移位数
    private final long dataCenterIdShift = sequenceBits + workerIdBits; // 数据中心 ID 左移位数
    private final long timestampLeftShift = sequenceBits + workerIdBits + dataCenterIdBits; // 时间戳左移位数

    private long workerId;      // 机器 ID
    private long dataCenterId;  // 数据中心 ID
    private long sequence = 0L; // 当前序列号
    private long lastTimestamp = -1L; // 上次生成 ID 的时间戳

    public SnowflakeIdGenerator(long workerId, long dataCenterId) {
        if (workerId > maxWorkerId || workerId < 0) {
            throw new IllegalArgumentException("Worker ID out of range");
        }
        if (dataCenterId > maxDataCenterId || dataCenterId < 0) {
            throw new IllegalArgumentException("Data Center ID out of range");
        }
        this.workerId = workerId;
        this.dataCenterId = dataCenterId;
    }

    public synchronized long nextId() {
        long timestamp = System.currentTimeMillis();

        if (timestamp < lastTimestamp) {
            throw new RuntimeException("Clock moved backwards. Refusing to generate ID");
        }

        if (timestamp == lastTimestamp) {
            sequence = (sequence + 1) & sequenceMask; // 当前毫秒内递增
            if (sequence == 0) {
                timestamp = waitForNextMillis(lastTimestamp); // 序列号用完，等待下一毫秒
            }
        } else {
            sequence = 0L; // 不同毫秒，重置序列号
        }

        lastTimestamp = timestamp;

        return ((timestamp - epoch) << timestampLeftShift) // 时间戳部分
                | (dataCenterId << dataCenterIdShift)      // 数据中心 ID
                | (workerId << workerIdShift)              // 机器 ID
                | sequence;                                // 序列号
    }

    private long waitForNextMillis(long lastTimestamp) {
        long timestamp = System.currentTimeMillis();
        while (timestamp <= lastTimestamp) {
            timestamp = System.currentTimeMillis();
        }
        return timestamp;
    }
}
```



## 3.2 实现优惠券秒杀下单

![image-20241215152523676](./assets/image-20241215152523676.png)

基本的下单实现代码：

```java
public Result seckillVoucher(Long voucherId) {
    // 1. 查询秒杀信息
    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);

    // 2. 判断秒杀时间
    if (voucher.getBeginTime().isAfter(LocalDateTime.now()) || voucher.getEndTime().isBefore(LocalDateTime.now())) {
        return Result.fail("不在秒杀时间范围内");
    }

    // 3. 判断库存
    if (voucher.getStock() <= 0) {
        return Result.fail("库存不足");
    }

    // 4. 扣减库存
    voucher.setStock(voucher.getStock() - 1);
    boolean update = seckillVoucherService.updateById(voucher);
    if (!update) {
        return Result.fail("扣减库存失败");
    }

    // 5. 生成订单
    long orderId = redisIdWorker.nextId("order");
    VoucherOrder order = new VoucherOrder()
            .setVoucherId(voucherId)
            .setId(orderId)
            .setUserId(UserHolder.getUser().getId());
    save(order);

    // 6. 返回结果
    return Result.ok(orderId);
}
```



## 3.3 解决秒杀过程超卖问题

![image-20241215155015682](./assets/image-20241215155015682.png)

选用乐观锁时有两种方式：

![image-20241215155420923](./assets/image-20241215155420923.png)

![image-20241215155458224](./assets/image-20241215155458224.png)

采用CAS法实现乐观锁代码如下，但是采用这种方式时，出现剩余大量库存的情况。因为只有有人修改了之后，别的线程都会失败，而不管是否是真的已经库存不足。

```java
// 4. 扣减库存
boolean update = seckillVoucherService.update()
    .setSql("stock = stock - 1")
    .eq("id", voucherId)
    .eq("stock", voucher.getStock())
    .update();
```



因此，我们可以对锁进行改进，如下所示：

```java
boolean update = seckillVoucherService.update()
        .setSql("stock = stock - 1")
        .eq("id", voucherId)
        .gt("stock", 0)
        .update();
```



## 3.4 实现一人一单功能

![image-20241215160502015](./assets/image-20241215160502015.png)

核心代码如下：

```java
int count = voucherOrderService.query()
        .eq("voucher_id", voucherId)
        .eq("user_id", UserHolder.getUser().getId())
        .count();

if (count > 0) {
    return Result.fail("不能重复购买");
}
```

但是仅仅这样是不够的，因为这是典型的“查询-检查-操作”行为，必须要加锁来确保其线程安全。因此我们可以考虑如下方案，将创建订单抽取出来，对整个方法添加锁和事务

```java
@Transactional
public synchronized Result createOrder(Long voucherId) {
    // 3. 判断是否重复购买
    int count = voucherOrderService.query()
        .eq("voucher_id", voucherId)
        .eq("user_id", UserHolder.getUser().getId())
        .count();

    if (count > 0) {
        return Result.fail("不能重复购买");
    }
    
    // ... 其他相关业务代码
}
```

---

这样又引发了新的问题，由于锁加在方法上，因此所有线程创建订单的行为就会串行化，这并不是我们希望的，我们希望的每个用户持有一个自己的锁，防止重复下单。那么，上述代码又可以进行如下优化：

> [!WARNING]
>
> 此处应使用`voucherId.toString().intern()`而不能直接使用`voucherId.toString()`加锁，因为后者在每次调用都会生成一个新的字符串对象，这就使得锁机制失效，无法正确同步多个线程对同一资源的访问

```java
@Transactional
public Result createOrder(Long voucherId) {    
	synchronized (voucherId.toString().intern()) {
        int count = voucherOrderService.query()
                .eq("voucher_id", voucherId)
                .eq("user_id", UserHolder.getUser().getId())
                .count();

        if (count > 0) {
            return Result.fail("不能重复购买");
        }

        // ... 其他相关业务代码
    }
}
```

---

但是按照这种加锁方法，事务的提交是在锁的释放之后，因此仍然存在线程安全问题，所以我们需要把锁移至`createOrder()`方法的的调用处，这样才能保证事务是在加锁期间完成。

```java
synchronized (voucherId.toString().intern()){
    return createOrder(voucherId);
}
```

---

还有最后一个错误，像这样会出现**同类方法调用事务失效** 问题，在这种情况下，事务无法生效的主要原因是通过this调用方法时，调用不会通过代理对象。

- Spring事务是通过AOP代理实现的，`@Transactional`的逻辑仅在代理对象上生效。
- 直接调用`this.innerTransactionalMethod`绕过了代理对象，导致事务逻辑未被触发。

为了解决这个问题，我们可以通过通过AOP上下文获取代理对象，如下所示：

```java
synchronized (voucherId.toString().intern()) {
    IVoucherOrderService service = (IVoucherOrderService) AopContext.currentProxy();
    return service.createOrder(voucherId);
}
```

使用了这种方式后，还应该引入如下依赖：

```xml
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
</dependency>
```

并且在启动类中添加注解暴露代理对象：

```java
@EnableAspectJAutoProxy(exposeProxy = true)
```

---

至此，一人一单的业务成功完成，完成代码如下所示：

```java
@Override
@Transactional
public Result seckillVoucher(Long voucherId) {
    // 1. 查询秒杀信息
    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);

    // 2. 判断秒杀时间
    if (voucher.getBeginTime().isAfter(LocalDateTime.now()) || voucher.getEndTime().isBefore(LocalDateTime.now())) {
        return Result.fail("不在秒杀时间范围内");
    }

    // 3. 判断库存
    if (voucher.getStock() <= 0) {
        return Result.fail("库存不足");
    }

    // 4. 生成订单
    synchronized (voucherId.toString().intern()) {
        IVoucherOrderService service = (IVoucherOrderService) AopContext.currentProxy();
        return service.createOrder(voucherId);
    }
}

@Override
@Transactional
public Result createOrder(Long voucherId) {
    // 4.1 判断是否重复购买

    int count = voucherOrderService.query()
            .eq("voucher_id", voucherId)
            .eq("user_id", UserHolder.getUser().getId())
            .count();

    if (count > 0) {
        return Result.fail("不能重复购买");
    }

    // 4.2 扣减库存
    boolean update = seckillVoucherService.update()
            .setSql("stock = stock - 1")
            .eq("voucher_id", voucherId)
            .gt("stock", 0)
            .update();
    if (!update) {
        return Result.fail("扣减库存失败");
    }

    // 4.3 生成订单
    long orderId = redisIdWorker.nextId("order");
    VoucherOrder order = new VoucherOrder()
            .setVoucherId(voucherId)
            .setId(orderId)
            .setUserId(UserHolder.getUser().getId());
    save(order);

    return Result.ok(voucherId);
}
```



## 3.5 分布式锁

### 1. 集群模式下锁的失效

![image-20241215180714669](./assets/image-20241215180714669.png)

在上述一人一单的业务中，我们采用了Java内置的`synchronized`锁来确保线程安全。但是当后端服务集群部署时，这种锁就会在不同的节点间失效，因为内置锁是由JVM的锁监视器维护的。因此我们需要采用新的模式来解决集群中的并发问题。

### 2. 什么是分布式锁

![image-20241215182901156](./assets/image-20241215182901156.png)

分布式锁是一种用于分布式系统中协调多个节点访问共享资源的机制。它确保在多个节点并发操作共享资源时，不会出现数据竞争或数据一致性问题。分布式锁类似于单机系统中的互斥锁，但它需要在分布式环境下实现。

**应用场景**

1. **限流与并发控制**：控制资源的并发访问数量，例如限速或限流。
2. **任务调度**：确保一个任务在某个时间点只有一个实例在运行。
3. **资源分配**：对共享资源（如库存、文件）进行锁定操作，防止超卖或重复操作。
4. **分布式事务**：协调分布式事务的执行顺序或状态一致性。



**分布式锁的关键问题**

1. **互斥性**：确保同一时刻只有一个客户端能获取锁。
2. **死锁问题**：加锁后因异常未释放，需通过过期时间解决。
3. **锁的可重入性**：是否允许同一个客户端重复加锁。
4. **锁的粒度**：应根据需求合理划分锁定资源的范围。
5. **高可用性**：锁服务的可靠性需保障，避免单点故障。



**常见实现方式**

1. **基于数据库的分布式锁**

   - **原理**：通过数据库的唯一性约束实现锁。比如，插入一条唯一标识的记录来表示加锁，删除记录表示释放锁。
     - 优点：
       - 实现简单，依赖已有数据库。

   - **缺点**：
     - 性能较低，适合低并发场景。
       - 存在可能因为客户端崩溃而导致锁失效的问题，需要额外机制清理死锁。

2. **基于缓存（Redis）的分布式锁**

   - **原理**：使用 Redis 的 `SETNX`（Set if Not Exists）命令加锁，并通过设置过期时间防止死锁。Redis 的 Lua 脚本保证操作的原子性。

   - **优点**：
     - 性能高，适合高并发场景。
       - Redis 的主从同步和哨兵机制可以提供更高的可靠性。

- **缺点**：
  - 需要处理锁自动过期的问题，避免资源被误释放。

3. **基于 Zookeeper 的分布式锁**

   - **原理**：利用 Zookeeper 的节点机制（创建临时顺序节点）实现分布式锁。节点创建失败表示加锁失败，删除节点表示释放锁。
     - **优点**：
       - 提供强一致性，适合对一致性要求高的场景。
       - 天然支持锁的失效检测（通过临时节点）。

   - **缺点**：
     - 性能相对较低。
       - 依赖 Zookeeper 集群，部署和维护成本较高。

![image-20241215183510222](./assets/image-20241215183510222.png)



### 3. 用Redis实现分布式锁

![image-20241215184257468](./assets/image-20241215184257468.png)

实现代码：

```java
public class SimpleRedisLock implements ILock {
    private String name;
    private StringRedisTemplate stringRedisTemplate;
    private static final String LOCK_PREFIX = "lock:";

    public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) {
        this.name = name;
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Override
    public boolean tryLock(long timeoutSeconds) {
        long threadId = Thread.currentThread().getId();
        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(LOCK_PREFIX + name,
                String.valueOf(threadId), timeoutSeconds, TimeUnit.SECONDS);

        return Boolean.TRUE.equals(success);
    }

    @Override
    public void unlock() {
        stringRedisTemplate.delete(LOCK_PREFIX + name);
    }
}
```



这样我们就可以利用这个分布式锁，对之前的一人一单业务进行优化：

```java
// 4. 生成订单
SimpleRedisLock lock = new SimpleRedisLock("voucher:" + voucherId, stringRedisTemplate);

if (!lock.tryLock(5)) {
    return Result.fail("请勿重复点击");
}
try {
    return ((VoucherOrderServiceImpl) AopContext.currentProxy()).createOrder(voucherId);
} finally {
    lock.unlock();
}
```



### 4. Redis分布式锁误删问题

Redis分布式锁误删问题是指在某些场景下，Redis锁的持有者可能意外删除了另一个持有者正在使用的锁，从而导致锁失效，进而引发共享资源被多个客户端同时访问的问题。

**锁过期导致误删**

- 场景：
  - 客户端 A 获取锁，并设置过期时间。
  - 由于网络延迟或其他原因，操作时间超出了锁的有效期。
  - 锁过期后，客户端 B 成功获取锁。
  - 客户端 A 执行释放锁逻辑，但由于 A 不知道锁已经过期并被 B 获取，它直接删除了锁。
- 结果：客户端 B 的锁被误删，导致共享资源暴露。

**锁非唯一性问题**

- 如果 Redis 锁的值没有唯一标识，不同客户端可能误删彼此的锁。例如，不同客户端的锁值都设为默认值（如 `"LOCKED"`），导致释放锁时无法区分锁的归属。



解决思路：

![image-20241215194906535](./assets/image-20241215194906535.png)

修改代码：

```java
public class SimpleRedisLock implements ILock {
    // ...

    private static final String LOCK_PREFIX = "lock:";
    private static final String VALUE_PREFIX = UUID.randomUUID().toString(true) + "-";

    @Override
    public boolean tryLock(long timeoutSeconds) {
        // 存储唯一值用于判断
        String value = VALUE_PREFIX + Thread.currentThread().getId();
        Boolean success = stringRedisTemplate.opsForValue()
                .setIfAbsent(LOCK_PREFIX + name, value, timeoutSeconds, TimeUnit.SECONDS);

        return Boolean.TRUE.equals(success);
    }

    @Override
    public void unlock() {
        // 1. 判断是否是自己的锁
        String value = stringRedisTemplate.opsForValue().get(LOCK_PREFIX + name);
        if (StrUtil.equals(value, VALUE_PREFIX + Thread.currentThread().getId())) {
            // 2. 删除锁
            stringRedisTemplate.delete(LOCK_PREFIX + name);
        }
    }
}
```

但是由于这种方法仍然属于先判断后操作，存在可能的并发问题，因此我们需要找到一种原子的方式来释放锁。



### 5. Redis的Lua脚本

Redis 的 Lua 脚本是 Redis 提供的一种内置功能，允许用户通过 Lua 编程语言编写脚本，并在 Redis 服务器端以原子方式执行这些脚本。这种功能增强了 Redis 的灵活性和性能，特别适用于需要多个 Redis 命令一起执行且保持原子性的一些场景。

**Redis 的 Lua 脚本**是 Redis 提供的一种内置功能，允许用户通过 Lua 编程语言编写脚本，并在 Redis 服务器端以原子方式执行这些脚本。这种功能增强了 Redis 的灵活性和性能，特别适用于需要多个 Redis 命令一起执行且保持原子性的一些场景。



**Lua 脚本的特点**

1. **原子性**：
   - Redis 的 Lua 脚本在执行期间是单线程操作，不会被其他命令打断。
   - 脚本中的所有命令要么全部执行成功，要么全部失败（如遇错误）。
2. **高性能**：
   - 脚本直接在 Redis 服务器端运行，减少了客户端与服务器之间的多次网络往返，提升性能。
3. **灵活性**：
   - 支持复杂的逻辑操作，可以通过 Lua 编程语言实现 Redis 的基本命令无法直接完成的功能。
4. **安全性**：
   - Redis 提供了受限的 Lua 环境，禁止访问文件系统、网络等外部资源，专注于 Redis 数据操作。



**Lua 脚本的常用命令**：`EVAL`直接执行 Lua 脚本。

- **语法**：

  ```bash
  EVAL script numkeys key [key ...] arg [arg ...]
  ```

  - `script`: Lua 脚本的代码。
  - `numkeys`: 键的数量。
  - `key [key ...]`: 键名。
  - `arg [arg ...]`: 额外的参数。

- 示例：

  ```bash
  EVAL "return redis.call('set', KEYS[1], ARGV[1])" 1 mykey myvalue
  ```

  上述脚本等价于：

  ```bash
  SET mykey myvalue
  ```



**分布式锁释放的脚本：**

```lua
if redis.call('GET', KEYS[1]) == ARGV[1] then
    return redis.call('DEL', KEYS[1])
else
    return 0
end
```



### 6. 在Java中使用lua脚本

![image-20241215201659321](./assets/image-20241215201659321.png)



利用Lua脚本改造释放锁的方法：

```java
private static final DefaultRedisScript<Long> UNLOCK_SCRIPT;

static {
    UNLOCK_SCRIPT = new DefaultRedisScript<>();
    UNLOCK_SCRIPT.setResultType(Long.class);
    UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));
}

public void unlock() {
    stringRedisTemplate.execute(
        UNLOCK_SCRIPT,
        Collections.singletonList(LOCK_PREFIX + name),
        VALUE_PREFIX + Thread.currentThread().getId());
}
```

