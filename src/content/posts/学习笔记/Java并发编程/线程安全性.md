---
title: Java并发编程-线程安全性
published: 2024-10-17
description: 《Java并发编程实战》第2章 - 线程安全性学习笔记
image: ./assets/cover.jpg
tags: [Java并发编程]
category: 学习笔记
draft: false
---
> [!NOTE]
> 本篇笔记基于《Java并发编程实战》第2章 - 线程安全性
# 1. 线程安全性
当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些线程将交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么这个类就是线程安全的。

在对线程安全性的定义中，最核心的内容就是正确性，其含义是某个类的行为与其规范完全一致，即所见即所知。因此，我们可以给出对于**安全性的定义：当多个线程访问某个类时，这个类始终能表现出正确的行为。**



为了更好的进行说明，下面给出一个简单的Servlet的例子，这样一个Servlet就是无状态的。当多个线程访问它时，线程之间并不会互相影响，因为两个线程之间并没有共享状态。

```java
@ThreadSafe
public class StatelessFactorizer implements Servlet {
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }
}
```

:::tip[无状态对象]
既不包含任何域，也不包含任何对其他类中域的引用，因此一定是线程安全的
:::


# 2. 原子性
当我们在无状态对象中增加一个状态后，会发生什么现象？

我们继续沿用上述的例子，但是加入一个新的计数器`count`，当Servlet每接收到一次请求时，就会进行一次计数。`++count`这个操作看上去只有一步，但实际上它是非原子的，因为它是一个“读取—修改—写入”的系列操作。这就使得这个Servlet变为**非线程安全**的了，因为当存在多个线程同时请求时，会出现同时读取和修改的情况，这就导致了count的值出现错误。

```java
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
    private long count = 0;

    public long getCount() { return count; }

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        ++count;
        encodeIntoResponse(resp, factors);
    }
}
```



在并发编程中，我们称这种情况为**竞态条件（Race Condition）**，即由于不恰当的执行顺序而出现结果不正确的情况。最常见的竞态条件就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作。

使用“先检查后执行”操作的一种常见情况就是延迟初始化。延迟初始化的目的是将对象的初始化操作推迟到实际使用时才进行，同时要确保只初始化一次。下面这个例子中就包含了一个这样的一个竞态条件：当线程A和线程B同时执行`getInstance()`时，由于不可预测的时许和线程的调度方式等多种因素，就可能导致两个线程都判断`instance`为`null`，因此返回两个不同的结果。

```java
@NotThreadSafe
public class LazyInitRace {
    private ExpensiveObject instance = null;

    public ExpensiveObject getInstance() {
        if (instance == null) {
            instance = new ExpensiveObject();
        }
        return instance;
    }
}
```

因此，为了避免竞态条件问题，我们需要让这些操作以原子方式执行。也就是在某个线程修改变量时，通过某种方式防止其他线程使用这个变量，从而确保线程安全。

> [!NOTE]
>
> 假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说就是原子的

于是我们回到之前给出涉及到计数器的例子，我们可以使用`AtomicLong`来代替`long`类型的计数器，借助原子变量类来确保所有操作都是原子的。这样虽然我们在无状态的类中添加了一个状态，但是该状态完全由线程安全的对象来管理，那么这个类任然是线程安全的。

```java
@ThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
    private final AtomicLong count = new AtomicLong(0);

    public long getCount() { return count.get(); }

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        count.incrementAndGet();
        encodeIntoResponse(resp, factors);
    }
}
```

> [!tip]
>
> 关于原子变量将在15章进一步介绍
