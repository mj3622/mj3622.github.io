---
title: Python 实战笔记：从 Pandas 描述性统计、SciPy 假设检验到 FastAPI 服务端开发 
published: 2026-01-14 
description: 本文通过五个具体的编程实战案例，详细解析了如何使用 Pandas 进行多维度的描述性统计（均值、标准差、标准误差），如何利用 SciPy 进行卡方检验与配对样本检验，以及如何使用 FastAPI 结合 Pydantic 构建一个标准的 BMI 计算 Web 服务。 
tags: [Python, Pandas, SciPy, FastAPI, 统计学, Pydantic, Web开发] 
category: 学习笔记
draft: false
---
## 前言

在数据科学的学习中，我们经常需要在“统计分析”和“应用开发”两种思维模式间切换。今天的实战笔记将通过 5 个具体的问题，串联起 Python 数据生态中的三个核心库：**Pandas**（用于数据处理）、**SciPy**（用于统计检验）和 **FastAPI**（用于构建 Web 服务）。

本文不仅提供经过优化的代码，更会深入剖析代码背后的统计学原理和 Python 语法细节，特别适合初学者理解和复习。

## 第一部分：Pandas 中的描述性统计 (Descriptive Statistics)

在处理矩阵数据（DataFrame）时，我们经常需要从“行”和“列”两个不同的维度来观察数据。

### 1. 核心知识点

* **均值 (Mean):** 数据的平均水平。
* **标准差 (Standard Deviation, SD):** 反映数据的离散程度（波动大小）。
* **标准误差 (Standard Error of the Mean, SEM):** 反映**样本均值**的可靠性。简单来说，如果你多次抽样，每次算出的均值之间的差异有多大。
* *注意：很多初学者分不清 SD 和 SEM。SD 描述数据本身，SEM 描述均值的准确度。*


* **轴 (Axis) 的概念：** 这是 Pandas 中最容易晕的概念。
* `axis=0`: **跨行操作**（沿着纵向切），结果是压缩成一行（计算每一列的特征）。
* `axis=1`: **跨列操作**（沿着横向切），结果是压缩成一列（计算每一行的特征）。



### 2. 代码修正与实战

**原始代码中的小问题：** 在你的 `problem_2` 函数中，提前初始化 `row_mean = 0` 等变量是多余的。Python 是动态类型语言，直接赋值即可。

**优化后的代码：**

```python
import pandas as pd

def problem_2(df):
    """
    输入: df (Pandas DataFrame)
    输出: 行均值, 行标准差, 列均值, 列标准误差
    """
    # 1. 计算行均值 (Row Mean)
    # axis=1: 横向计算，算出每一行的平均数
    row_mean = df.mean(axis=1)
    
    # 2. 计算行标准差 (Row Standard Deviation)
    # Pandas 默认 ddof=1 (样本标准差)，这是统计学中的无偏估计
    row_sd = df.std(axis=1)
    
    # 3. 计算列样本均值 (Column Sample Mean)
    # axis=0: 纵向计算，算出每一列的平均数
    column_sample_mean = df.mean(axis=0)
    
    # 4. 计算列样本标准误差 (Column Sample Error)
    # 使用 sem() 函数直接计算
    column_ss = df.sem(axis=0)
    
    return row_mean, row_sd, column_sample_mean, column_ss

```

---

## 第二部分：SciPy 中的假设检验 (Hypothesis Testing)

统计检验的核心是回答：“眼前的这个现象，是由于某种规律造成的，还是纯属巧合？”

### 1. 卡方检验 (Chi-square Test) —— 谁动了我的骰子？

**场景：** 我们有一副特殊的骰子（面上的数字是 1,1,2,3,4,4），我们需要判断它掷出的结果是否符合数学理论。

**核心逻辑：**

* **观测频数 (Observed):** 实际掷出来的次数。
* **期望频数 (Expected):** 理论上应该出现的次数。
* **P值 (p-value):** 如果 P 值很小（通常 < 0.05），说明“观测”和“期望”差别太大，不太可能是巧合，骰子可能被动了手脚（或者变质了）。

**代码解析：**

```python
from scipy.stats import chisquare

def problem_3(list_of_observation):
    # 1. 准备“尺子”：理论概率 (需预先算好)
    # 这是一个数学问题：两颗怪骰子(1,1,2,3,4,4)加起来的和
    # 和为5的情况有10种组合，总组合36种，所以概率是 10/36
    expected_probs = [4/36, 4/36, 5/36, 10/36, 5/36, 4/36, 4/36]
    possible_sums = [2, 3, 4, 5, 6, 7, 8]
    
    total_observations = len(list_of_observation)
    
    # 2. 计算期望频数 (Expected Frequencies)
    # 理论次数 = 总次数 * 理论概率
    f_exp = [p * total_observations for p in expected_probs]
    
    # 3. 统计实际频数 (Observed Frequencies)
    f_obs = []
    for s in possible_sums:
        # list.count(s) 会遍历列表统计 s 出现的次数
        c = list_of_observation.count(s)
        f_obs.append(c)
    
    # 4. 执行检验
    # chisquare 函数会自动对比 f_obs 和 f_exp
    result = chisquare(f_obs=f_obs, f_exp=f_exp)
    
    return result.pvalue, result.statistic

```

### 2. 配对检验 —— T检验 vs Wilcoxon

**场景：** 比较两组**成对**数据（例如：同一个班级补习前后的成绩）。

**知识点辨析：**

* **配对 T 检验 (`ttest_rel`):** 参数检验。假设数据差值服从**正态分布**。对数据分布有要求，但统计效力强。
* **Wilcoxon 符号秩检验 (`wilcoxon`):** 非参数检验。**不假设**数据服从正态分布。它不看具体数值差多少，只看“排名”。适用性更广。

**代码解析：**

```python
from scipy.stats import ttest_rel, wilcoxon

def problem_4(df):
    # iloc[:, 0] 取所有行的第0列
    column_1 = df.iloc[:, 0]
    column_2 = df.iloc[:, 1]
    
    # 方法1: T检验
    pairt = ttest_rel(column_1, column_2).pvalue
    
    # 方法2: Wilcoxon检验
    # 注意：如果数据中有重复值(ties)，计算出的p值是近似值
    w = wilcoxon(column_1, column_2).pvalue
    
    return pairt, w

```

---

## 第三部分：FastAPI 服务端开发 (Web Implementation)

做完数据分析后，我们往往需要将其封装成 Web 应用。这里我们使用现代 Python 最流行的框架 **FastAPI** 来搭建一个 BMI 计算器。

### 1. 核心知识点

* **Pydantic 模型 (`BaseModel`):** 这是 FastAPI 的灵魂。它用于**数据验证**。定义好 `ModelData` 后，如果前端传过来一个字符串类型的身高（例如 "tall"），FastAPI 会自动报错，省去了我们写 `if type(x) != float` 的麻烦。
* **Annotated & Form:** 用于告诉 FastAPI，“请去 HTML 的 `<form>` 表单里把数据扣出来”。
* **Jinja2Templates:** 用于渲染 HTML 页面（即把 Python 里的数据塞进网页，或者直接返回网页文件）。

### 2. 代码实战 (Problem 5 & 6)

这是一个完整的后端服务脚本。请注意 `Annotated` 的用法以及 JSON 响应的结构。

```python
# 引入必要的库
from typing import Annotated
from fastapi import FastAPI, Form, Request
from fastapi.responses import JSONResponse, HTMLResponse
from fastapi.encoders import jsonable_encoder
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel
import uvicorn

# --- 知识点 1: 定义数据模型 ---
# 这就像一个“模具”，规定了前端传来的数据必须包含 height 和 weight，且必须是数字
class ModelData(BaseModel):
    height: float
    weight: float

app = FastAPI()
# 设置存放 HTML 文件的文件夹
templates = Jinja2Templates(directory='templates')

# --- 知识点 2: 编写 API 接口 ---

# 接口 A: 处理计算请求 (POST)
# 只有当用户点击 Submit 提交表单时，才会触发这个接口
@app.post("/model/")
async def login(data: Annotated[ModelData, Form()]):
    # FastAPI 已经帮我们把表单数据转换成了 ModelData 对象
    h = data.height
    w = data.weight
    
    # 业务逻辑：防止除以 0 错误
    if h == 0:
        response_data = {"result": -1.0, "error": "Height is zero"}
    else:
        # 计算 BMI
        bmi = w / (h * h)
        response_data = {"result": bmi, "error": ""}

    # 返回 JSON 格式的数据给前端
    return JSONResponse(content=jsonable_encoder(response_data), status_code=200)

# 接口 B: 展示网页 (GET)
# 当用户访问主页 http://localhost:55726/ 时触发
@app.get('/', response_class=HTMLResponse)
async def main(request: Request):
    # 返回 problem5.html 页面
    # 注意：你需要确保目录下有 templates/problem5.html 文件
    return templates.TemplateResponse('problem5.html', {'request': request})

# --- 知识点 3: 启动服务器 ---
if __name__ == "__main__":
    # host="0.0.0.0" 允许局域网访问
    # port=55726 是自定义端口
    uvicorn.run(app, host="0.0.0.0", port=55726)

```

## 总结

通过这五个问题，我们其实完成了一次微型的全栈数据科学实践：

1. 用 **Pandas** 理解数据的分布特征。
2. 用 **SciPy** 验证数据背后的规律。
3. 用 **FastAPI** 将计算逻辑包装成产品。

这些代码片段虽然短小，但涵盖了 Python 数据处理最核心的范式。建议大家在本地运行这些代码，尝试修改其中的参数（例如改变骰子的概率、修改 BMI 的计算公式），以加深理解。